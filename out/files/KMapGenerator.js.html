<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>KMapGenerator.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/KMap.html">KMap</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/KMapGenerator.html">KMapGenerator</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: KMapGenerator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Karnaugh Map Generator.
 *
 * By Antonio García Díaz.
 *
 * Université Libre de Bruxelles 2016-2017.
 *
 * This module was created as a javascript web application to automatically generate K-Map exercices and their solutions.
 * It uses a method (pseudo-ESPRESSO) based on the ESPRESSO algorithm to calculate an optimal cover of the K-Map using n-cubes, and display the solution linked to said covering.
 * The application is meant to be used in conjunction with KarnaughMap.html, which provides an HTML layout to showcase the application.
 *
 * @module KMapGenerator
 */

//----------------------------------------------------------------------------------
//-------------------------INITIALISATION OF VARIABLES------------------------------
//----------------------------------------------------------------------------------

/**
 * A class meant to represent a Karnaugh Map (KMap) through a matrix (array of arrays).
 * It also contains information about an optimal cover of said map, which is dynamically calculated every time it is modified.
 *
 * In addition, the class possesses the methods and static properties needed to calculate such a cover, and display the K-Map as an interactive HTML interface.
 * The cover is calculated using a pseudo-ESPRESSO method (based on the ESPRESSO algorithm).
 *
 * @class KMap
 */


//----------------------------------------------------------------------------------
//-----------------------------CONSTANT PROPERTIES----------------------------------
//----------------------------------------------------------------------------------

/**
 * Names used for each possible variable.
 *
 * @property varNames
 * @type {Array}
 * @default [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;]
 */
var varNames = new Array(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;); // Names used for each possible variable
/**
 * Number of &quot;levels&quot; of the K-Map for each numVar (KLvl[0] and KLvl[1] are unused).
 * There is only one level unless we use 5 variables. Then the K-Map becomes &quot;3D&quot;, and there are two levels.
 *
 * @property KLvl
 * @type {Array}
 * @default [0,1,1,1,1,2]
 */
var KLvl = new Array(0,1,1,1,1,2);
/**
 * Width of the K-Map for each numVar (KWid[0] and KWid[1] are unused).
 *
 * @property KWid
 * @type {Array}
 * @default [0,2,2,4,4,4]
 */
var KWid  = new Array(0,2,2,4,4,4);
/**
 * Height of K-Map for each numVar (KHei[0] and KHei[1] are unused).
 *
 * @property KHei
 * @type {Array}
 * @default [0,1,2,2,4,4]
 */
var KHei = new Array(0,1,2,2,4,4);
/**
 * Number of variables written horizontally for each numVar.
 *
 * @property KVarX
 * @type {Array}
 * @default [0,1,1,2,2,2]
 */
var KVarX  = new Array(0,1,1,2,2,2);
/**
 * Number of variables written vertically for each numVar
 *
 * @property KVarY
 * @type {Array}
 * @default [0,0,1,1,2,2]
 */
var KVarY = new Array(0,0,1,1,2,2);
/**
 * The order of bits as represented in a K-Map (00, 01, 11, 10).
 *
 * @property bitOrd
 * @type {Array}
 * @default [0,1,3,2,4,5,7,6]
 */
var bitOrd = new Array(0,1,3,2,4,5,7,6);
/**
 * A string specifying the name of the &quot;normal&quot; color for spaces in the K-Map.
 *
 * @property normalColor
 * @type {String}
 * @default &quot;white&quot;
 */
var normalColor = &quot;white&quot;;			// 0xFFFFFF;
/**
 * A string specifying the name of the color used for selected spaces in the K-Map.
 *
 * @property selectColor
 * @type {String}
 * @default &quot;yellow&quot;
 */
var selectColor = &quot;yellow&quot;;			// 0xFFFF00;


//----------------------------------------------------------------------------------
//-----------------------------VARIABLE PROPERTIES----------------------------------
//----------------------------------------------------------------------------------


/**
 * The number of logic variables for the K-Map.
 *
 * @property numVar
 * @type {Integer}
 * @default 4
 */
var numVar = 4;
/**
 * Wether the K-Map may have &quot;don&#x27;t care&quot; symbols or not.
 *
 * @property allowDC
 * @type {Boolean}
 * @default false
 */
var allowDC = false;
/**
 * The content of the K-Map itself, as an array of arrays.
 *
 * @property KMap
 * @type {Array}
 * @default []
 */
var KMap = [];
/**
 * The list of covered spaces in the K-Map, as an array of coordinates.
 *
 * @property coverList
 * @type {Array}
 * @default []
 */
var coverList = [];
/**
 * The list of n-cubes that form an optimal cover of the K-Map, as an array of arrays of coordinates.
 *
 * @property nCubeList
 * @type {Array}
 * @default []
 */
var nCubeList = [];


initKMap(numVar);


//----------------------------------------------------------------------------------
//---------------------SIMPLE FORMAT TRANSLATION FUNCTIONS--------------------------
//----------------------------------------------------------------------------------


/**
* From integers val and b, produces a string that expresses val as a b-bit binary value.
*
* @method toBinString
* @param val {Integer} The integer value to be converted to binary.
* @param b {Integer} The maximum number of binary bits to be retained in val.
* @return {String} Returns a string expressing val as a binary number of less than b bits.
*/
function toBinString (val, b){
    var str = val.toString(2);
    for (var i=0; i&lt;b; i++){
        if (str.length&lt;b) str = &quot;0&quot; + str;
    }
    if (b===0) str = &quot;&quot;;
    return str;
}

/**
* From an integer (representing a boolean as a binary cypher, or a don&#x27;t care as anything else),
* produces a corresponding string. Said string contains the same binary cypher if boolean,
* or &quot;_&quot; if don&#x27;t care.
*
* @method boolToBin
* @param bool {Integer} A value that represents a boolean, or don&#x27;t care.
* @return {String} Returns &quot;1&quot; if bool = 1 (true), &quot;0&quot; if bool = 0 (false), and &quot;_&quot; otherwise (don&#x27;t care).
*/
function boolToBin (bool){
    if (bool === 1) return &quot;1&quot;;
    else if (bool === 0) return &quot;0&quot;;
    else return &quot;-&quot;;
}


//----------------------------------------------------------------------------------
//-----------------------------THE ESPRESSO ALGORITHM-------------------------------
//----------------------------------------------------------------------------------


/**
* Checks wether a given n-cube can be accepted by the K-Map.
*
* An n-cube is accepted only if it contains no 0 values, and it contains at least one 1 value.
* Indeed, from the logic of favorising the largest possible n-cubes, it follows that a cube with
* no 0 values is accepted, even if most other values are &quot;don&#x27;t cares&quot;, as long as it has a single
* 1 value at least.
*
* @method checkCube
* @param coords {Array} An array containing the coordinates of the n-cube&#x27;s first (top-left-front) space.
* @param sizes {Array} An array containing the dimensions of the n-cube (in spaces).
* @return {Bool} Wether the n-cube is accepted (contains no 0 values at least one 1 value).
*/
function checkCube(coords, sizes){
    var no0val = true; // Remains true until a 0 value is found (we stop searching then).
    var has1val = false; // Remains false until a 1 value is found.
    for (var d=coords[2]; d&lt;sizes[2]+coords[2] &amp;&amp; no0val; d++){
    for (var w=coords[0]; w&lt;sizes[0]+coords[0] &amp;&amp; no0val; w++){
    for (var h=coords[1]; h&lt;sizes[1]+coords[1] &amp;&amp; no0val; h++){
        no0val = no0val &amp;&amp; KMap[d][w%KMap.Width][h%KMap.Height].Value;
        has1val = has1val || KMap[d][w%KMap.Width][h%KMap.Height].Value == 1;
    }}}
    return (no0val &amp;&amp; has1val);
}


/**
* Checks wether a given n-cube can be accepted by the K-Map.
*
* An n-cube is accepted only if it contains no 0 values, and it contains at least one 1 value.
* Indeed, from the logic of favorising the largest possible n-cubes, it follows that a cube with
* no 0 values is accepted, even if most other values are &quot;don&#x27;t cares&quot;, as long as it has a single
* 1 value at least.
*
* @method makeCube
* @param coords {Array} An array containing the coordinates of the n-cube&#x27;s first (top-left-front) space.
* @param sizes {Array} An array containing the dimensions of the n-cube (in spaces).
* @return {Array} An array of spaces representing the n-cube&#x27;s portion of the K-Map.
*/
function makeCube(coords, sizes){
    var newCube = [];
    for (var d=coords[2]; d&lt;sizes[2]+coords[2]; d++){
    for (var w=coords[0]; w&lt;sizes[0]+coords[0]; w++){
    for (var h=coords[1]; h&lt;sizes[1]+coords[1]; h++){
        newCube.push([w%KMap.Width,h%KMap.Height,d]);
    }}}
    return newCube;
}


/**
* Within an n-cube array, eliminates any n-cubes whose spaces are entirely covered by other n-cubes in the array.
*
* @method checkForCollisions
* @param nCubeArray {Array} An array of arrays, each representing the portion of the K-Map covered by an n-cube.
* @return {Array} Returns a new array containing the maximal n-cubes from the original, those that were not contained in another n-cube.
*/
function checkForCollisions(nCubeArray) {
	var newCubeArray = [];
    var toKeep = [];
    var contained = false;
    for (var i=0; i&lt;nCubeArray.length; i++){
        contained = false;
        for (var j=0; j&lt;nCubeArray.length; j++){
			if ( i!=j &amp;&amp;  nCubeArray[i].length &lt; nCubeArray[j].length){
				contained = contained || isContainedIn(nCubeArray[i],nCubeArray[j]);
			}
            else if ( j&lt;i &amp;&amp; nCubeArray[i].length == nCubeArray[j].length ){
				contained = contained || isContainedIn(nCubeArray[i],nCubeArray[j]);
			}
		}
        if (!contained) {toKeep.push(i);}
    }
    for (var k=0; k&lt;toKeep.length; k++){
        newCubeArray.push(nCubeArray[toKeep[k]]);
    }
    return newCubeArray;
}


/**
* Checks if an n-cube is contained in another. Returns true if nCube1 is contained in nCube2.
*
* This function  be used in a larger context, with nCube1 and nCube2 being any two lists of spaces from the K-Map (and not necessarily n-cubes).
* The usage is then the same, to check if one contains the other.
*
* @method isContainedIn
* @param nCube1 {Array} An array of spaces, usually representing an n-cube&#x27;s portion of the K-Map.
* @param nCube2 {Array} Another array of spaces, usually representing another n-cube&#x27;s portion of the K-Map.
* @return {Bool} Returns true if the spaces in nCube1 are part of the spaces in nCube2, false otherwise.
*/
function isContainedIn(nCube1,nCube2){
    var check = 0; var found = false;
    for (var i=0; i&lt;nCube1.length; i++){
		found = false;
        for (var j=0; j&lt;nCube2.length; j++){
            if(nCube1[i][0] == nCube2[j][0] &amp;&amp; nCube1[i][1] == nCube2[j][1] &amp;&amp; nCube1[i][2] == nCube2[j][2]){
                found = true;
            }
        }
		if(found){check += 1;}
    }
    return (check == nCube1.length);
}


/**
* Returns true if a given space can already be found in a given list of (covered) spaces.
* Used to test wether a space that is detected as covered has been already added to the &quot;covered spaces&quot; list or not.
*
* @method alreadyCovered
* @param space {Array} The coordinates of a space in the K-Map, that has been detected as covered.
* @param cover {Array} An array of space coordinates. Usually the list of covered spaces, still being built.
* @return {Bool} Wether the space is already in the list of covered spaces or not.
*/
function alreadyCovered(space, cover){
    var covered = false;
    for (var i=0; i&lt;cover.length; i++){
        if(space[0] == cover[i][0] &amp;&amp; space[1] == cover[i][1] &amp;&amp; space[2] == cover[i][2]) covered = true;
    }
    return covered;
}


/**
* Generates a list of covered spaces in the K-Map from a list of n-cubes (representing a cover of said map).
*
* @method getCoverList
* @param nCubeArray {Array} An array of arrays, each representing an n-cube&#x27;s portion of the K-Map.
* @return {Array} An array representing a cover of the K-Map, containing the coordinates of covered spaces.
*/
function getCoverList(nCubeArray){
    cover = [];
    for (var i=0; i&lt;nCubeArray.length; i++){
        for (var j=0; j&lt;nCubeArray[i].length; j++){
            if(!alreadyCovered(nCubeArray[i][j], cover)) cover.push(nCubeArray[i][j]);
    }}
    return cover;
}


/**
* Checks if a list of covered spaces contains all of the 1 values in the K-Map.
*
* @method coversAll1
* @param cover {Array} An array of spaces in the K-Map.
* @return {Bool} Returns false if at least one 1 value falls outside the array of spaces, true otherwise.
*/
function coversAll1(cover){
    var check = true;
    for (var d=0; d&lt;KMap.nLevels; d++){
    for (var w=0; w&lt;KMap.Width; w++){
    for (var h=0; h&lt;KMap.Height; h++){
        if(KMap[d][w][h].Value == 1 &amp;&amp; !alreadyCovered([w,h,d], cover)) check = false;
    }}}
    return check;
}


/**
* The &quot;expand&quot; step of the pseudo-ESPRESSO algorithm.
*
* Each new n-cube is expanded towards every direction (width, height, and square) until it cannot be expanded anymore,
* creating various candidate &quot;expanded&quot; n-cubes. These cubes are then added to the n-cube list.
* Finally, if any expanded n-cubes is contained within another expanded cube, it is removed from the list.
*
* In the 5-variable case, n-cubes that cover both levels of depth (E and notE), are treated separately from other cubes,
* although using the same tree-choice layout for their expansion. This is because, by using that choice layout, it is possible
* to find a 1-1 association of every case of 1-level-deep cube with a distinct case of 2-levels-deep cube.
*
* @method EspressoExpand
*/
function EspressoExpand() {
	var newCubeSet = []; // All of the expanded n-cubes created from a single space, regardless of wether some cubes contain others.

    var w = 0; var h = 0; var d = 0;

	while(d&lt;KMap.nLevels){
        // For 1-level deep n-cubes (cover either E or notE in the 5 variable case).
        while(h&lt;KMap.Height){
            while(w&lt;KMap.Width){
				newCubeSet = [];

	            if( checkCube([w,h,d], [1,1,1]) ){
                    newCubeSet.push(makeCube([w,h,d], [1,1,1]));

    				//Expanding for n-cubes oriented along the width.
                    if( checkCube([w,h,d], [2,1,1]) ){
                        newCubeSet.push(makeCube([w,h,d], [2,1,1]));
                        //In case a cube takes the whole width.
                        if( KMap.Width==4 &amp;&amp; w===0 ){
                            if( checkCube([w,h,d], [4,1,1]) ) newCubeSet.push(makeCube([w,h,d], [4,1,1]));
                            if( checkCube([w,h,d], [4,2,1]) ) newCubeSet.push(makeCube([w,h,d], [4,2,1]));
                        }
                        newCubeSet = checkForCollisions(newCubeSet);
                    }

                    //Expanding for n-cubes oriented along the height.
                    if( checkCube([w,h,d], [1,2,1]) ){
                        newCubeSet.push(makeCube([w,h,d], [1,2,1]));
                        //In case a cube takes the whole height.
                        if( KMap.Height==4 &amp;&amp; h===0 ){
                            if( checkCube([w,h,d], [1,4,1]) ) newCubeSet.push(makeCube([w,h,d], [1,4,1]));
                            if( checkCube([w,h,d], [2,4,1]) ) newCubeSet.push(makeCube([w,h,d], [2,4,1]));
                        }
                        newCubeSet = checkForCollisions(newCubeSet);
                    }

                    //Expanding for square n-cubes.
                    if( checkCube([w,h,d], [2,2,1]) ){
                        newCubeSet.push(makeCube([w,h,d], [2,2,1]));
                        //In case a cube takes the whole width and height.
        				if( w===0 &amp;&amp; h===0 &amp;&amp; KMap.Width==4 &amp;&amp; KMap.Height==4){
                            if( checkCube([w,h,d], [4,4,1]) ) newCubeSet.push(makeCube([w,h,d], [4,4,1]));
                        }
                        newCubeSet = checkForCollisions(newCubeSet);
                    }
                }

	            for (var i=0; i&lt;newCubeSet.length; i++){ nCubeList.push(newCubeSet[i]); }
	            w += 1;
	        }
	        w = 0; h += 1;
		}
		w = 0; h = 0;

        // For 2-levels deep n-cubes (cover E AND notE in the 5 variable case).
        if(d===0 &amp;&amp; KMap.nLevels==2){
            while(h&lt;KMap.Height){
                while(w&lt;KMap.Width){
                    newCubeSet = [];

                    if( checkCube([w,h,d], [1,1,2]) ){
                        newCubeSet.push(makeCube([w,h,d], [1,1,2]));

                        //Expanding for n-cubes oriented along the width.
                        if( checkCube([w,h,d], [2,1,2]) ){
                            newCubeSet.push(makeCube([w,h,d], [2,1,2]));
                            //In case a cube takes the whole width.
                            if( KMap.Width==4 &amp;&amp; w===0 ){
                                if( checkCube([w,h,d], [4,1,2]) ) newCubeSet.push(makeCube([w,h,d], [4,1,2]));
                                if( checkCube([w,h,d], [4,2,2]) ) newCubeSet.push(makeCube([w,h,d], [4,2,2]));
                            }
                            newCubeSet = checkForCollisions(newCubeSet);
                        }

                        //Expanding for n-cubes oriented along the height.
                        if( checkCube([w,h,d], [1,2,2]) ){
                            newCubeSet.push(makeCube([w,h,d], [1,2,2]));
                            //In case a cube takes the whole height.
                            if( KMap.Width==4 &amp;&amp; w===0 ){
                                if( checkCube([w,h,d], [1,4,2]) ) newCubeSet.push(makeCube([w,h,d], [1,4,2]));
                                if( checkCube([w,h,d], [2,4,2]) ) newCubeSet.push(makeCube([w,h,d], [2,4,2]));
                            }
                            newCubeSet = checkForCollisions(newCubeSet);
                        }

                        //Expanding for square n-cubes.
                        if( checkCube([w,h,d], [2,2,2]) ){
                            newCubeSet.push(makeCube([w,h,d], [2,2,2]));
                            //In case a cube takes the whole width and height.
                            if( w===0 &amp;&amp; h===0 &amp;&amp; KMap.Width==4 &amp;&amp; KMap.Height==4){
                                if( checkCube([w,h,d], [4,4,2]) ) newCubeSet.push(makeCube([w,h,d], [4,4,2]));
                            }
                            newCubeSet = checkForCollisions(newCubeSet);
                        }
                    }

                    for (var j=0; j&lt;newCubeSet.length; j++){ nCubeList.push(newCubeSet[j]); }
                    w += 1;
                }
                w = 0; h += 1;
            }
            w = 0; h = 0;
        }
        w = 0; h = 0; d +=1;
    }
    nCubeList = checkForCollisions(nCubeList);
}


/**
* The &quot;irredundant cover&quot; step of the pseudo-ESPRESSO algorithm.
*
* The number of n-cubes in the cover is reduced to a minimum, eliminating any redundant cubes.
* This is achieved by itterating over the list of n-cubes until no more cubes can be removed.
*
* Each cube is first temporally eliminated from the list, to check if the previous cover (with the cube)
* is contained in the new one (without the cube).
* Since the opposite is always true, this would mean that the covers are identical.
*
* In case the covers are in fact not identical, and if &quot;don&#x27;t care&quot; values are possible,
* it is instead checked wether all of the spaces with a 1 value are covered by the new cover.
*
* If any of these conditions apply, the n-cube is considered redundant and definitively removed from the list.
* Otherwise, if the covers are not identical (and if 1 values are left out), the n-cube is considered essential
* and is retained in the list.
*
* @method EspressoIrredundantCover
*/
function EspressoIrredundantCover() {
    coverList = getCoverList(nCubeList);
    var lastIter = false;
    var newNCubeList = [];
    var newCover = [];
    while(lastIter === false){
        //If the previous itteration didn&#x27;t remove any n-cubes, it becomes the last iteration and the algorithm stops.
        lastIter = true;
        for (var i=0; i&lt;nCubeList.length; i++){
            //We itterate from the first n-cube on the list onwards. That is, from the top-left corner.
            newNCubeList = JSON.parse(JSON.stringify(nCubeList));
            newNCubeList.splice(i, 1);
            newCover = getCoverList(newNCubeList);
            //We check if the old cover is contained in the new one, to see if they are the same (the new one is always contained in the old one).
            if( isContainedIn(coverList,newCover) ){
                nCubeList = newNCubeList; coverList = newCover;
                lastIter = false;
            }
            //Alternatively, in the &quot;don&#x27;t care&quot; case, we check if all the 1 values are still contained within the cover.
            else if (allowDC &amp;&amp; coversAll1(newCover)) {
                nCubeList = newNCubeList; coverList = newCover;
                lastIter = false;
            }
        }
    }
}



/**
* Starts the pseudo-ESPRESSO algorithm for the current state of the K-Map.
*
* Resets the lists of n-cubes and of covered spaces, and calls the functions for each step of the algorithm.
*
* @method EspressoSolve
*/
function EspressoSolve() {
	nCubeList = [];
	coverList = [];
    EspressoExpand();
    EspressoIrredundantCover();
}


//----------------------------------------------------------------------------------
//-------------------FUNCTIONS FOR CREATING AND MANAGING K-MAPS---------------------
//----------------------------------------------------------------------------------

/**
 * Resets and rebuilds the KMap matrix and its attributes, with a given number of logic variables.
 *
 * @method initKMap
 * @param nVar {Integer} The number of variables for the map.
 */
function initKMap (nVar){
    KMap = [];
    KMap.nLevels = KLvl[nVar];
    KMap.Width = KWid[nVar];
    KMap.Height = KHei[nVar];
    KMap.nVarX = KVarX[nVar];
    KMap.nVarY = KVarY[nVar];
    for (var d=0; d&lt;KMap.nLevels; d++){
        KMap[d] = [];
        for (var w=0; w&lt;KMap.Width; w++){
    		KMap[d][w] = [];
    		for (var h=0; h&lt;KMap.Height; h++){
    			KMap[d][w][h] = [];
    			KMap[d][w][h].Value = 0; // False is default
    			valueStr = toBinString(bitOrd[d],KMap.nLevels-1) + toBinString(bitOrd[w],KMap.nVarX) + toBinString(bitOrd[h],KMap.nVarY);
    			value = parseInt(valueStr,2);

    			KMap[d][w][h].Button_id = &quot;KM&quot; + valueStr;
    			KMap[d][w][h].TD_id = &quot;TD&quot; + valueStr;
    	}}
    }
}


/**
* Simply resets and redraws the K-Map, using the current number of variables.
*
* @method resetKMap
*/
function resetKMap(){
    initKMap(numVar); redraw();
}


/**
* Changes the number of variables of the K-Map, resetting it in the process.
*
* @method changeNumVar
* @param Num {Integer} The new number of variables for the map.
*/
function changeNumVar(Num){
    if(Num != numVar){
        numVar = Num; initKMap(Num);
        document.getElementById(&quot;Var2&quot;).checked = (Num==2)?true:false;
        document.getElementById(&quot;Var3&quot;).checked = (Num==3)?true:false;
        document.getElementById(&quot;Var4&quot;).checked = (Num==4)?true:false;
        document.getElementById(&quot;Var5&quot;).checked = (Num==5)?true:false;
    }
    redraw();
}


/**
* Switches wether the K-Map allows for &quot;don&#x27;t care&quot; symbols or not, resetting it in the process.
*
* @method switchDontCare
*/
function switchDontCare(){
    allowDC = !allowDC;
    for (var d=0; d&lt;KMap.nLevels; d++){
    for (var w=0; w&lt;KMap.Width; w++){
    for (var h=0; h&lt;KMap.Height; h++){
        if(KMap[d][w][h].Value === 2) KMap[d][w][h].Value = 0;
    }}}
    redraw();
}


/**
* Modifies an entry in the K-Map, switching its value attribute (an integer)
* between 0 (false), 1 (true), and 2 (don&#x27;t care).
*
* @method modifyKMEntry
* @param entry {Variable} A reference to an entry of the K-Map.
*/
function modifyKMEntry(entry){
    if (entry.Value === 0) entry.Value = 1;
    else if (entry.Value === 1 &amp;&amp; allowDC) entry.Value = 2;
    else entry.Value = 0;
    redraw();
}


//----------------------------------------------------------------------------------
//----------------------FUNCTIONS FOR THE AESTHETICS OF THE GUI---------------------
//----------------------------------------------------------------------------------


/**
 * Sets the color for each space in the K-Map&#x27;s HTML representation back to its normal value.
 *
 * @method setAllToNormalColor
 */
function setAllToNormalColor(){
    for (d=0; d&lt;KMap.nLevels; d++){
        for (h=0; h&lt;KMap.Height; h++){
            for (w=0; w&lt;KMap.Width; w++){
                    document.getElementById(KMap[d][w][h].Button_id).style.backgroundColor = normalColor;
    }}}
}


/**
 * Sets the color of a group of spaces in the K-Map&#x27;s HTML representation to a given color.
 *
 * @method setColor
 * @param nCube {Array} An array of coordinates corresponding to spaces in the K-Map, usually an n-cube.
 * @param color {String} A string specifying the color that the set of spaces will take.
 */
function setColor(nCube,color){
    for(var i=0; i&lt;nCube.length; i++){
        document.getElementById(KMap[nCube[i][2]][nCube[i][0]][nCube[i][1]].Button_id).style.backgroundColor = color;
    }
}

/**
 * Redraws the HTML display of the KMap and its solution.
 *
 * @method redraw
 */
function redraw(){
    document.getElementById(&quot;KMapMaker&quot;);
    document.getElementById(&quot;KMapDiv&quot;).innerHTML = generateKMapHTML();
    document.getElementById(&quot;SolutionDiv&quot;).innerHTML = generateSolutionHTML();
    document.getElementById(&quot;LaTeXCode&quot;).value = generateLaTeXCode();
}


/**
 * Generates a new HTML code for the K-Map. The map is displayed as a matrix of clickable buttons.
 *
 * @method generateKMapHTML
 * @return {String} The new HTML code for the K-Map.
 */
 function generateKMapHTML() {
     var text = &quot;&lt;center&gt;To begin, please input your K-Map using the interface below.&lt;/center&gt;&quot;;
     text += &quot;\n&lt;center&gt;By clicking on the K-Map&#x27;s spaces, their binary values can be switched between &#x27;0&#x27; (false), &#x27;1&#x27; (true), and &#x27;-&#x27; (don&#x27;t care).&lt;/center&gt;&quot;;
     text += &quot;&lt;center&gt;&lt;small&gt;An exportable LaTeX code for the current K-Map &lt;a href=&#x27;#LaTeX&#x27;&gt;is available below&lt;/a&gt;.&lt;/small&gt;&lt;/center&gt;&lt;br /&gt;&lt;center&gt;&quot;;
     var h,w,d; //Using a 3D table helps to account for 5 variables;


     //text += &quot;&lt;table border=1&gt;&quot;;
     text += &quot;&lt;table&gt;&quot;;

 	//Width of the matrix
 	text += &quot;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th colspan=&quot;+KMap.Width*KMap.Height+2+&quot;&gt;&quot;;
 	for (var i=0; i&lt;KMap.nVarX+KMap.nLevels-1; i++){
 		text += varNames[i];
 	}

 	text += &quot;&lt;/th&gt;&lt;/tr&gt;&quot;;
 	text += &quot;&lt;tr&gt;&quot;;
 	text += &quot;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&quot;;
    for (d=0; d&lt;KMap.nLevels; d++){
 	for (w=0; w&lt;KMap.Width; w++){
        if (w===0 &amp;&amp; d==1) text += &quot;&lt;th style=&#x27;width:1mm&#x27;&gt;&lt;/th&gt;&quot;;
 		text += &quot;&lt;th&gt;&quot;+toBinString(bitOrd[d*4+w],KMap.nVarX+KMap.nLevels-1)+&quot;&lt;/th&gt;&quot;;
    }}
 	text+=&quot;&lt;/tr&gt;&quot;;

 	//Height of the matrix
 	for (h=0; h&lt;KMap.Height; h++){
 		text = text + &quot;&lt;tr&gt;&quot;;
 		if (h===0){
            text += &quot;&lt;th rowspan=&quot;+KMap.Height+&quot;&gt;&quot;;
 			for (var j=0; j&lt;KMap.nVarY; j++){
 				text += varNames[j+KMap.nVarX+KMap.nLevels-1];
 			}
            text += &quot;&lt;th rowspan=&quot;+KMap.Height+&quot;&gt;&quot;;
 		}
 		text += &quot;&lt;th&gt;&quot;+toBinString (bitOrd[h],KMap.nVarY)+&quot;&lt;/th&gt;&quot;;

 		//Filling the matrix with buttons
        for (d=0; d&lt;KMap.nLevels; d++){
 		for (w=0; w&lt;KMap.Width; w++){
            if (w===0 &amp;&amp; d==1) text += &quot;&lt;th style=&#x27;width:1mm&#x27;&gt;&lt;/th&gt;&quot;;
 			text += &quot;&lt;td  ID=&#x27;&quot;+KMap[d][w][h].TFD_id+&quot;&#x27;; style=&#x27;background-color:0xFF&#x27;&gt;&quot;;
 			text += &quot;&lt;input ID=&quot;+KMap[d][w][h].Button_id +&quot; name=&quot;+KMap[d][w][h].Button_id;
            text += &quot; type=&#x27;button&#x27;  style=&#x27;height:6mm;width:8mm&#x27; value=&#x27; &quot;+ boolToBin(KMap[d][w][h].Value);
            text += &quot; &#x27;; onClick=modifyKMEntry(KMap[&quot;+d+&quot;][&quot;+w+&quot;][&quot;+h+&quot;]);&gt;&lt;/td&gt;&quot;;
 		}}
 		text += &quot;&lt;/tr&gt;&quot;;
 	}
    text += &quot;&lt;/table&gt;&quot;;
 	text+=&quot;&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;

 	return text;
}


/**
* Returns, for a given n-cube, its corresponding term in the cover&#x27;s logic function (HTML version).
* Uses the binary strings related to each space covered by the n-cube, and compares them,
* to know which logic variables are concerned, and in which state they are accepted.
*
* If the mouse is hovered on the term, its corresponding n-cube will light up on the K-Map.
*
* @method getFunctionHTML
* @param nCube {Array} An array representing an n-cube&#x27;s portion of the K-Map.
* @param cubeId {Integer} The place of the n-cube in the list of cubes, used to generate interactive HTML code.
* @return {String} A string representing a term in the logic function, related to the n-cube.
*/
function getFunctionHTML(nCube, cubeId){
	var ref = toBinString(bitOrd[nCube[0][2]],KMap.nLevels-1) + toBinString(bitOrd[nCube[0][0]],KMap.nVarX) + toBinString(bitOrd[nCube[0][1]],KMap.nVarY);
	var logicFunct = [];
	for(var x=0; x&lt;ref.length; x++) logicFunct[x] = parseInt(ref[x]);
	//N-cubes containing just one space will have a term given by a single binary string.
	//The term from the first space is thus stored in logicFunct.
	if (nCube.length &gt;= 2){
		//If the n-cube in fact covers more than one space, we compare the binary strings of new spaces with logicFunct.
		//Whenever in those strings we find a bit that differs from the correspondent one in logicFunct, it is overwritten with a &quot;2&quot;.
		for (var i=1; i&lt;nCube.length; i++){
			ref = toBinString(bitOrd[nCube[i][2]],KMap.nLevels-1) + toBinString(bitOrd[nCube[i][0]],KMap.nVarX) + toBinString(bitOrd[nCube[i][1]],KMap.nVarY);
			for (var j=0; j&lt;ref.length; j++){
				if (logicFunct[j] != parseInt(ref[j])) logicFunct[j] = 2;
		}}
	}
	//From the final version of logicFunct, we build the expression of the term with letters.
	//If the bit corresponding to a logic variable A is 0, we write notA. If it is 1, we write A.
	//If it is 2, we don&#x27;t write anything (meaning we don&#x27;t care about the variable A).
	var funct = &quot;&lt;span ID=&quot; + cubeId;
    funct += &quot; onMouseOver=&#x27;setColor(nCubeList[&quot;+cubeId+&quot;],selectColor);&#x27;&quot;;
    funct += &quot; onMouseOut=&#x27;setColor(nCubeList[&quot;+cubeId+&quot;],normalColor);&#x27;&gt;&quot;;
    var wholeMap = true;
	for (var k=0; k&lt;logicFunct.length; k++){
		if (logicFunct[k] === 0){
			wholeMap = false;
			funct += &quot;&lt;span style=&#x27;text-decoration: overline&#x27;&gt;&quot; + varNames[k] + &quot;&lt;/span&gt;&quot;;
		}
		else if (logicFunct[k] == 1){
			wholeMap = false;
			funct += varNames[k];
		}
	}
	if (wholeMap) funct += &quot;1&quot;;
    else funct += &quot;&lt;/span&gt;&quot;;
	return funct;
}


/**
* Generates a new HTML code for the K-Map&#x27;s solution (a logic function that expresses its cover by the n-cubes).
*
* @method generateSolutionHTML
* @return {String} The new HTML code to show the cover&#x27;s logic function.
*/
function generateSolutionHTML(){
    setAllToNormalColor(); //Before anything, we set the K-Map&#x27;s overal color to its normal, non-selected state.
    EspressoSolve();
    var text = &quot;&lt;h4&gt;&lt;center&gt;K-Map cover function:&lt;/center&gt;&lt;/h4&gt;&quot;;
    text+=&quot;&lt;h2&gt;&lt;center&gt;F(&quot;;
    for (var x=0; x&lt;(KMap.nVarX+KMap.nVarY+KMap.nLevels-1); x++){
        text += varNames[x]; if(x!=(KMap.nVarX+KMap.nVarY+KMap.nLevels-2)) text += &quot;,&quot;;
    }
    text+=&quot;) = &quot;;
    if (nCubeList.length === 0){ text += &quot;0&quot;; } //Case where no spaces are covered.
    else{ for (var i=0; i&lt;nCubeList.length; i++){
        text += getFunctionHTML(nCubeList[i], i);
        if (i&lt;nCubeList.length-1) text += &quot; + &quot;;
        //Code used for testing purposes, to express the cover as a list of n-cubes, rather than a function.
        /*
        text+=&quot;&lt;li&gt;n-cube #&quot; + i + &quot; : &quot;;
        for(var j=0; j&lt;nCubeList[i].length; j++){
            text +=&quot;(&quot; + toBinString (bitOrd[nCubeList[i][j][0]],KMap.nVarX);
            text += toBinString (bitOrd[nCubeList[i][j][1]],KMap.nVarY) + &quot;) &quot;;
        }
        text+=&quot;&lt;/li&gt;\n&quot;;
        */
    }}
    text+=&quot;&lt;/center&gt;&lt;/h2&gt;&quot;;
    text+=&quot;&lt;center&gt;&lt;small&gt;PROTIP: Hover the mouse over each term in the equation to lighten up the corresponding n-cube.&lt;/small&gt;&lt;/center&gt;&quot;;

    return text;
}


//----------------------------------------------------------------------------------
//-----------------------FUNCTIONS FOR PRODUCING THE LATEX CODE---------------------
//----------------------------------------------------------------------------------

/**
 * Writes a string of LaTeX code to use as the document&#x27;s header.
 * This sets the proper LaTeX configuration to display the K-Map.
 *
 * @method writeDocHeader
 * @return {String} The LaTeX code for displaying the n-cubes.
 */
function writeDocHeader(){
    var code = &quot;\\documentclass[a4paper,10pt]{ltxdoc}\n&quot;;
    code += &quot;\\usepackage[a4paper]{geometry}\n\n&quot;;
    code += &quot;\\usepackage[scaled=0.92]{helvet}\n&quot;;
    code += &quot;\\usepackage{sansmath}\n&quot;;
    code += &quot;\\usepackage{color}\n&quot;;
    code += &quot;\\usepackage{float}\n&quot;;
    code += &quot;\\usepackage{listings}\n&quot;;
    code += &quot;\\usepackage{array}\n\n&quot;;
    code += &quot;\\usepackage{askmaps}\n\n&quot;;

    code += &quot;\\definecolor{red}{rgb}{1,0,0}\n&quot;;
    code += &quot;\\definecolor{green}{rgb}{0,1,0}\n&quot;;
    code += &quot;\\definecolor{blue}{rgb}{0,0,1}\n&quot;;
    code += &quot;\\definecolor{darkred}{rgb}{0.5,0,0}\n&quot;;
    code += &quot;\\definecolor{darkgreen}{rgb}{0,0.5,0}\n&quot;;
    code += &quot;\\definecolor{darkblue}{rgb}{0,0,0.5}\n&quot;;
    code += &quot;\\definecolor{yellow}{rgb}{1,1,0}\n&quot;;
    code += &quot;\\definecolor{cyan}{rgb}{0,1,1}\n&quot;;
    code += &quot;\\definecolor{magenta}{rgb}{1,0,1}\n&quot;;
    code += &quot;\\definecolor{gray}{rgb}{0.5,0.5,0.5}\n&quot;;
    code += &quot;\\definecolor{orange}{rgb}{1,0.5,0}\n&quot;;
    code += &quot;\\definecolor{aqua}{rgb}{0,1,0.5}\n&quot;;
    code += &quot;\\definecolor{purple}{rgb}{0.5,0,1}\n&quot;;
    code += &quot;\\definecolor{fuschia}{rgb}{1,0,0.5}\n&quot;;
    code += &quot;\\definecolor{lime}{rgb}{0.5,1,0}\n&quot;;
    code += &quot;\\definecolor{azur}{rgb}{0,0.5,1}\n&quot;;

    return code;
}


/**
* Returns, for a given n-cube, its corresponding term in the cover&#x27;s logic function (text version).
* Uses the binary strings related to each space covered by the n-cube, and compares them,
* to know which logic variables are concerned, and in which state they are accepted.
*
* @method getFunctionText
* @param nCube {Array} An array representing an n-cube&#x27;s portion of the K-Map.
* @param cubeId {Integer} The place of the n-cube in the list of cubes, used to generate interactive HTML code.
* @return {String} A string representing a term in the logic function, related to the n-cube.
*/
function getFunctionText(nCube, cubeId){
    var ref = toBinString(bitOrd[nCube[0][2]],KMap.nLevels-1) + toBinString(bitOrd[nCube[0][0]],KMap.nVarX) + toBinString(bitOrd[nCube[0][1]],KMap.nVarY);
	var logicFunct = [];
    for(var x=0; x&lt;ref.length; x++) logicFunct[x] = parseInt(ref[x]);
    if (nCube.length &gt;= 2){
        for (var i=1; i&lt;nCube.length; i++){
			ref = toBinString(bitOrd[nCube[i][2]],KMap.nLevels-1) + toBinString(bitOrd[nCube[i][0]],KMap.nVarX) + toBinString(bitOrd[nCube[i][1]],KMap.nVarY);
			for (var j=0; j&lt;ref.length; j++){
				if (logicFunct[j] != parseInt(ref[j])) logicFunct[j] = 2;
	}}}

    var funct = &quot;&quot;; var wholeMap = true;
	for (var k=0; k&lt;logicFunct.length; k++){
		if (logicFunct[k] === 0){
			wholeMap = false; funct += &quot;\\overline{&quot; + varNames[k] + &quot;}&quot;;
		}
        else if (logicFunct[k] == 1){
			wholeMap = false; funct += varNames[k];
		}
	}
	if (wholeMap) funct += &quot;1&quot;;
	return funct;
}


/**
* Writes the K-Map&#x27;s solution (a logic function that expresses its cover by the n-cubes) as a string of text.
*
* @method writeLogicFunction
* @return {String} The cover&#x27;s logic function as a string of text.
*/
function writeLogicFunction(){
    var text = &quot;F(&quot;;
    for (var x=0; x&lt;(KMap.nVarX+KMap.nVarY+KMap.nLevels-1); x++){
        text += varNames[x]; if(x!=(KMap.nVarX+KMap.nVarY+KMap.nLevels-2)) text += &quot;,&quot;;
    }
    text+=&quot;)=&quot;;
    if (nCubeList.length === 0){ text += &quot;0&quot;; } //Case where no spaces are covered.
    else{ for (var i=0; i&lt;nCubeList.length; i++){
        text += getFunctionText(nCubeList[i], i);
        if (i&lt;nCubeList.length-1) text += &quot;+&quot;;
    }}
    return text;
}


/**
 * Finds, for an n-cube, the lowest or highest value for a space&#x27;s for width, length, or depth, depending on the parameters.
 *
 * @method findExCoord
 * @param nCube {Array} An array of spaces, representing an n-cube&#x27;s portion of the K-Map.
 * @param ex {Integer} The kind of extreme requested. Set to 0 for lowest, 1 for highest.
 * @param coord {Integer} The kind of coordinate. Set to 0 for width, 1 for height, 2 for depth.
 * @return {Integer} The lowest or highest such coordinate found in in the the n-cube.
 */
function findExCoord(nCube,ex,coord){
    var size;
    switch(ex){
        case 0: size = 4; break;
        case 1: size = 0; break;
    }
    for (var i=0; i&lt;nCube.length; i++){ switch(ex){
            case 0: if (size &gt; nCube[i][coord]) size = nCube[i][coord]; break;
            case 1: if (size &lt; nCube[i][coord]) size = nCube[i][coord]; break;
    }}
    return size;
}


/**
 * Writes a string of LaTeX code to display the n-cubes in the K-Map.
 *
 * @method writeNCubes
 * @return {String} The LaTeX code for displaying the n-cubes.
 */
function writeNCubes(){
    var colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;cyan&quot;,&quot;magenta&quot;,&quot;darkred&quot;,&quot;darkgreen&quot;,&quot;darkblue&quot;,&quot;gray&quot;,&quot;orange&quot;,&quot;fuschia&quot;,&quot;azur&quot;,&quot;purple&quot;,&quot;aqua&quot;,&quot;lime&quot;];
    var code = &quot;\n&quot;;
    var goesOutW; //If the n-cube goes out of the K-Map and back in, widthwise.
    var goesOutH; //If the n-cube goes out of the K-Map and back in, heightwise.
    if (nCubeList.length !== 0){ for (var i=0; i&lt;nCubeList.length; i++){
        goesOutW = (nCubeList[i][0][0]==3 &amp;&amp; findExCoord(nCubeList[i],0,0)===0);
        goesOutH = (nCubeList[i][0][1]==3 &amp;&amp; findExCoord(nCubeList[i],0,1)===0);
        for(var d=0; d&lt;2; d++){ if (findExCoord(nCubeList[i],d,2)==d){
            //For each depth level of the n-cube, if it exists.
            code += &quot;\\color{&quot; + colors[i%16] + &quot;}&quot;;
            code += &quot;\\put(&quot;+(4*d+nCubeList[i][0][0])+&quot;,&quot;+(KMap.Height-1-findExCoord(nCubeList[i],1,1))+&quot;.1)&quot;;
            if(goesOutW &amp;&amp; goesOutH){
                code += &quot;{\\dashbox{0.2}(0.8,0.8){}}\n&quot;;
                code += &quot;\\color{&quot; + colors[i%16] + &quot;}\\put(&quot;+(4*d)+&quot;,0.1){\\dashbox{0.2}(0.8,0.8){}}\n&quot;;
                code += &quot;\\color{&quot; + colors[i%16] + &quot;}\\put(&quot;+(4*d)+3+&quot;,3.1){\\dashbox{0.2}(0.8,0.8){}}\n&quot;;
                code += &quot;\\color{&quot; + colors[i%16] + &quot;}\\put(&quot;+(4*d)+&quot;,3.1){\\dashbox{0.2}(0.8,0.8){}}\n&quot;;
            }else if(goesOutW){
                code += &quot;{\\dashbox{0.2}(0.8,&quot;+(findExCoord(nCubeList[i],1,1)-findExCoord(nCubeList[i],0,1))+&quot;.8){}}\n&quot;;
                code += &quot;\\color{&quot; + colors[i%16] + &quot;}\\put(&quot;+(4*d)+&quot;,&quot;+(3-findExCoord(nCubeList[i],1,1))+&quot;.1)&quot;;
                code += &quot;{\\dashbox{0.2}(0.8,&quot;+(findExCoord(nCubeList[i],1,1)-findExCoord(nCubeList[i],0,1))+&quot;.8){}}\n&quot;;
            }else if(goesOutH){
                code += &quot;{\\dashbox{0.2}(&quot;+(findExCoord(nCubeList[i],1,0)-findExCoord(nCubeList[i],0,0))+&quot;.8,0.8){}}\n&quot;;
                code += &quot;\\color{&quot; + colors[i%16] + &quot;}\\put(&quot;+(4*d+nCubeList[i][0][0])+&quot;,3.1)&quot;;
                code += &quot;{\\dashbox{0.2}(&quot;+(findExCoord(nCubeList[i],1,0)-findExCoord(nCubeList[i],0,0))+&quot;.8,0.8){}}\n&quot;;
            }else{
                code += &quot;{\\dashbox{0.2}(&quot;+(findExCoord(nCubeList[i],1,0)-findExCoord(nCubeList[i],0,0))+&quot;.8,&quot;;
                code += (findExCoord(nCubeList[i],1,1)-findExCoord(nCubeList[i],0,1))+&quot;.8){}}\n&quot;;
            }
        }}
    }}
    return code;
}


/**
 * Generates a LaTeX document containing a representation of the K-Map.
 *
 * @method generateLaTeXCode
 * @return {String} The LaTeX code that represents the K-Map.
 */
function generateLaTeXCode(){
    var code = &quot;{\\fontfamily{phv}\\selectfont\\sansmath\n&quot;;
    code += &quot;\\askmap&quot;;

    //Number of variables.
    switch(numVar){
        case 2: code += &quot;ii&quot;; break;
        case 3: code += &quot;iii&quot;; break;
        case 4: code += &quot;iv&quot;; break;
        case 5: code += &quot;v&quot;; break;
    }
    code += &quot;{$&quot;;

    //Solution (logic function).
    code += writeLogicFunction();
    code += &quot;$}{&quot;;

    //Variable names.
    for (var x=0; x&lt;(KMap.nVarX+KMap.nVarY+KMap.nLevels-1); x++) code += varNames[x];
    code += &quot;}{}{&quot;;

    //Content of the K-Map.
    for (d=0; d&lt;KMap.nLevels; d++){
    for (w=0; w&lt;KMap.Width; w++){
    for (h=0; h&lt;KMap.Height; h++){
    	code += boolToBin(KMap[bitOrd[d]][bitOrd[w]][bitOrd[h]].Value);
    }}}
    code += &quot;}{&quot;;

    code += writeNCubes();
    code += &quot;}}\n\n&quot;;
	return code;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
